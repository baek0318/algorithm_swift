import Foundation

struct Position {
    var x : Int
    var y : Int
    var breaking : Bool
    var count : Int
}

let input = readLine()!.split(separator: " ").map{Int($0)!}
let n = input[0] //행
let m = input[1] //열
let px = [1, -1, 0, 0]
let py = [0, 0, -1, 1]
var maze = Array(repeating: Array(repeating: 0, count: m), count:n)
var queue = [Position]()
var ans = Int.max

for i in 0..<n {
    let put = readLine()!
    var j = 0
    for k in put {
        maze[i][j] = Int(String(k))!
        j+=1
    }
}

func bfs(_ x : Int, _ y : Int) {
    
    var po = 0
    queue.append(Position(x: x-1, y: y-1, breaking: false, count: 0))
    
    while !queue.isEmpty {
        
        let count = queue.count
        
        var value = queue[po]

        
        maze[value.x][value.y] = 2
        value.count += 1
        
        if value.x == n-1 && value.y == m-1 {
            if ans > value.count {
                ans = value.count
            }
        }
        
        for i in 0...3 {
            let nx = value.x+px[i]
            let ny = value.y+py[i]
            if value.breaking == false {
                if nx >= 0 && ny >= 0 && nx < n && ny < m && (maze[nx][ny] == 0 || maze[nx][ny] == 1) {
                    if maze[nx][ny] == 1 {
                        queue.append(Position(x: nx, y: ny, breaking: true, count: value.count))
                    }else {
                        queue.append(Position(x: nx, y: ny, breaking: value.breaking, count: value.count))
                    }
                    
                }
            }else {
                if nx >= 0 && ny >= 0 && nx < n && ny < m && maze[nx][ny] == 0 {
                    queue.append(Position(x: nx, y: ny, breaking: value.breaking, count: value.count))
                    
                }
            }
        }
        po+=1
        if po == count {
            queue.removeSubrange(0..<po)
            po=0
        }
    }
}

bfs(1, 1)
if ans == Int.max {
    print(-1)
}else {
    print(ans)
}

